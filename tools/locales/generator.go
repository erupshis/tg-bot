package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type Locale struct {
	Messages map[string]interface{} `yaml:"messages"`
}

type KeyGroup struct {
	Name      string
	Keys      []KeyDefinition
	Subgroups []KeyGroup
}

type KeyDefinition struct {
	Name string
	Path string
}

func main() {
	data, err := ioutil.ReadFile("locales/ru.yaml")
	if err != nil {
		log.Fatalf("error reading locale file: %v", err)
	}

	var locale Locale
	if err := yaml.Unmarshal(data, &locale); err != nil {
		log.Fatalf("error parsing YAML: %v", err)
	}

	rootGroup := buildKeyGroups("messages", locale.Messages)
	generateStructuredCode(rootGroup)
}

func buildKeyGroups(prefix string, data map[string]interface{}) KeyGroup {
	groupName := lastPart(prefix)
	group := KeyGroup{Name: toExportedName(groupName)}

	for k, v := range data {
		fullPath := prefix + "." + k
		switch v := v.(type) {
		case map[string]interface{}:
			subgroup := buildKeyGroups(fullPath, v)
			group.Subgroups = append(group.Subgroups, subgroup)
		default:
			group.Keys = append(group.Keys, KeyDefinition{
				Name: toExportedName(k),
				Path: fullPath,
			})
		}
	}

	return group
}

func generateStructuredCode(rootGroup KeyGroup) {
	tmpl := `// Code generated by locgen. DO NOT EDIT.

package locales

type MessageKey string

var Messages = {{ generateStruct . }}
`

	funcs := template.FuncMap{
		"generateStruct": func(g KeyGroup) string {
			var builder strings.Builder
			builder.WriteString("struct {\n")

			// Fields for current level
			for _, key := range g.Keys {
				builder.WriteString("\t" + key.Name + " MessageKey\n")
			}

			// Subgroups
			for _, subgroup := range g.Subgroups {
				builder.WriteString("\t" + subgroup.Name + " struct {\n")
				for _, sk := range subgroup.Keys {
					builder.WriteString("\t\t" + sk.Name + " MessageKey\n")
				}
				for _, ssub := range subgroup.Subgroups {
					builder.WriteString("\t\t" + ssub.Name + " struct {\n")
					for _, ssk := range ssub.Keys {
						builder.WriteString("\t\t\t" + ssk.Name + " MessageKey\n")
					}
					builder.WriteString("\t\t}\n")
				}
				builder.WriteString("\t}\n")
			}

			builder.WriteString("}{\n")

			// Initialize fields
			for _, key := range g.Keys {
				builder.WriteString("\t" + key.Name + ": \"" + key.Path + "\",\n")
			}

			// Initialize subgroups
			for _, subgroup := range g.Subgroups {
				builder.WriteString("\t" + subgroup.Name + ": struct {\n")
				for _, sk := range subgroup.Keys {
					builder.WriteString("\t\t" + sk.Name + " MessageKey\n")
				}
				for _, ssub := range subgroup.Subgroups {
					builder.WriteString("\t\t" + ssub.Name + " struct {\n")
					for _, ssk := range ssub.Keys {
						builder.WriteString("\t\t\t" + ssk.Name + " MessageKey\n")
					}
					builder.WriteString("\t\t}\n")
				}
				builder.WriteString("\t}{\n")

				for _, sk := range subgroup.Keys {
					builder.WriteString("\t\t" + sk.Name + ": \"" + sk.Path + "\",\n")
				}

				for _, ssub := range subgroup.Subgroups {
					builder.WriteString("\t\t" + ssub.Name + ": struct {\n")
					for _, ssk := range ssub.Keys {
						builder.WriteString("\t\t\t" + ssk.Name + " MessageKey\n")
					}
					builder.WriteString("\t\t}{\n")
					for _, ssk := range ssub.Keys {
						builder.WriteString("\t\t\t" + ssk.Name + ": \"" + ssk.Path + "\",\n")
					}
					builder.WriteString("\t\t},\n")
				}

				builder.WriteString("\t},\n")
			}

			builder.WriteString("}")
			return builder.String()
		},
	}

	t := template.Must(template.New("locales").Funcs(funcs).Parse(tmpl))

	outputFile, err := os.Create("./locales/locales.go")
	if err != nil {
		log.Fatal(err)
	}
	defer outputFile.Close()

	if err := t.Execute(outputFile, rootGroup); err != nil {
		log.Fatal(err)
	}

	fmt.Println("Successfully generated locales.go")
}

func lastPart(path string) string {
	parts := strings.Split(path, ".")
	return parts[len(parts)-1]
}

func toExportedName(s string) string {
	// Replace underscores with spaces, title case, then remove spaces
	return strings.ReplaceAll(strings.Title(strings.ReplaceAll(s, "_", " ")), " ", "")
}
